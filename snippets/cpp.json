{
	"CP Template (Single Run)": {
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"typedef long long ll;",
			"",
			"using namespace std;",
			"",
			"#define Mob                         \\",
			"  ios_base::sync_with_stdio(false); \\",
			"  cin.tie(NULL);",
			"#define lcm(a, b) ((a / __gcd(a, b)) * b)",
			"#define el \"\\n\"",
			"#define pii pair<int, int>",
			"#define pll pair<ll, ll>",
			"#define F first",
			"#define S second",
			"",
			"const bool is_testcases = ${1:true};",
			"const bool desync_stdio = false;",
			"",
			"auto solve(int tecs = -1)",
			"{",
			"  ${2:glhf}",
			"}",
			"",
			"// clang-format off",
			"void initialize()",
			"{",
			"}",
			"// clang-format on",
			"",
			"template <typename T>",
			"void call_solve(T f, int tecs = -1)",
			"{",
			"  using ReturnValue = invoke_result_t<decltype(f), int>;",
			"  if constexpr (is_same_v<ReturnValue, bool>) {",
			"    cout << (f(tecs) ? \"YES\" : \"NO\") << el;",
			"  } else if constexpr (is_same_v<ReturnValue, void>) {",
			"    f(tecs);",
			"  } else if constexpr (is_integral_v<ReturnValue>) {",
			"    cout << f(tecs) << el;",
			"  } else {",
			"    static_assert(",
			"      is_same_v<ReturnValue, void> || is_same_v<ReturnValue, bool> || is_integral_v<ReturnValue>,",
			"      \"solve() return type is not supported\");",
			"  }",
			"}",
			"",
			"int main()",
			"{",
			"  if constexpr (desync_stdio) {",
			"    Mob;",
			"  }",
			"",
			"  initialize();",
			"  if constexpr (is_testcases) {",
			"    int testcase;",
			"    cin >> testcase;",
			"    for (int tecs = 1; tecs <= testcase; tecs++) {",
			"      call_solve(solve, tecs);",
			"    }",
			"  } else {",
			"    call_solve(solve);",
			"  }",
			"}"
		]
	},
	"Stress Testing": {
		"prefix": "test",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"using namespace std;",
			"",
			"using ll = long long;",
			"using ull = unsigned long long;",
			"using pii = pair<int, int>;",
			"using pll = pair<ll, ll>;",
			"",
			"#define fi first",
			"#define se second",
			"#define pb push_back",
			"",
			"int correct(int n) {",
			"    ",
			"}",
			"",
			"int test(int n) {",
			"    ",
			"}",
			"",
			"int main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"",
			"    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
			"    while(1) {",
			"        int n = rng() % 100;",
			"        int out1 = correct(n);",
			"        int out2 = test(n);",
			"        if(out1 != out2) {",
			"            cout << \"Input:\\n\";",
			"            cout << n << '\\n';",
			"            cout << \"Expected Output:\\n\";",
			"            cout << out1 << '\\n';",
			"            cout << \"Received Output:\\n\";",
			"            cout << out2 << '\\n';",
			"            break;",
			"        }",
			"    }",
			"",
			"    return 0;",
			"}"
		]
	},
	"Binary Exponentiation": {
		"prefix": "power",
		"body": [
			"int mod = $0;",
			"",
			"ll power(ll x, ll y, ll m) {",
			"    ll res = 1;",
			"    x %= m;",
			"    while(y) {",
			"        if(y & 1) {",
			"            res = (res * x) % m;",
			"        }",
			"        x = (x * x) % m;",
			"        y = y >> 1;",
			"    }",
			"    return res;",
			"}"
		]
	},
	"Dijkstra's Algorithm": {
		"prefix": "dijkstra",
		"body": [
			"vector<vector<pll>> adj;",
			"",
			"vector<ll> dijkstra(int start) {",
			"    priority_queue<pll, vector<pll>, greater<pll>> pq;",
			"    vector<ll> dist(VERTEX_COUNT + 1, LLONG_MAX);",
			"    dist[start] = 0;",
			"    pq.push({0, start});",
			"    while(!pq.empty()) {",
			"        ll cur_dist = pq.top().fi;",
			"        ll cur_v = pq.top().se;",
			"        pq.pop();",
			"        if(cur_dist > dist[cur_v]) {",
			"            continue;",
			"        }",
			"        for(auto i : adj[cur_v]) {",
			"            ll next_v = i.fi;",
			"            ll weight = i.se;",
			"            if(dist[cur_v] + weight < dist[next_v]) {",
			"                dist[next_v] = dist[cur_v] + weight;",
			"                pq.push({dist[next_v], next_v});",
			"            }",
			"        }",
			"    }",
			"    return dist;",
			"}"
		]
	},
	"Depth First Search": {
		"prefix": "dfs",
		"body": [
			"vector<vector<int>> adj;",
			"vector<bool> vis;",
			"",
			"void dfs(int x) {",
			"    vis[x] = 1;",
			"    for(auto i : adj[x]) {",
			"        if(vis[i]) {",
			"            continue;",
			"        }",
			"        dfs(i);",
			"    }",
			"}"
		]
	},
	"Depth First Search (Tree)": {
		"prefix": "dfs_tree",
		"body": [
			"vector<vector<int>> adj;",
			"",
			"void dfs(int x, int p = -1) {",
			"    for(auto i : adj[x]) {",
			"        if(i == p) {",
			"            continue;",
			"        }",
			"        dfs(i, x);",
			"    }",
			"}"
		]
	},
	"Breadth First Search": {
		"prefix": "bfs",
		"body": [
			"queue<int> q;",
			"q.push(STARTING_VERTEX);",
			"while(!q.empty()) {",
			"    int cur = q.front();",
			"    q.pop();",
			"    for(auto i : adj[cur]) {",
			"        q.push(i);",
			"    }",
			"}"
		]
	},
	"Sparse Table": {
		"prefix": "sparse_table",
		"body": [
			"int st[30][n];",
			"for(int i = 1; (1 << i) <= n; i++) {",
			"    for(int j = 0; j + (1 << i) <= n; j++) {",
			"        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);",
			"    }",
			"}",
			"",
			"int x, y;",
			"cin >> x >> y;",
			"x--, y--;",
			"",
			"int z = log2(y - x + 1);",
			"cout << min(st[z][x], st[z][y - (1 << z) + 1]) << '\\n';"
		]
	},
	"Segment Tree": {
		"prefix": "segtree",
		"body": [
			"template<typename T, class F>",
			"struct segtree {",
			"    segtree(const vector<T>& arr, F f, T id) : merge(f), identity(id) {",
			"        n = arr.size();",
			"        tree.resize(n * 4, identity);",
			"        build(1, 0, n - 1, arr);",
			"    }",
			"",
			"    void update(int idx, T val) {",
			"        update(1, 0, n - 1, idx, val);",
			"    }",
			"",
			"    T query(int l, int r) {",
			"        return query(1, 0, n - 1, l, r);",
			"    }",
			"",
			"  private:",
			"    int n;",
			"    vector<T> tree;",
			"    F merge;",
			"    T identity;",
			"",
			"    void build(int node, int start, int end, const vector<T>& arr) {",
			"        if(start == end) {",
			"            tree[node] = arr[start];",
			"            return;",
			"        }",
			"        int mid = (start + end) / 2;",
			"        build(node * 2, start, mid, arr);",
			"        build(node * 2 + 1, mid + 1, end, arr);",
			"        tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);",
			"    }",
			"",
			"    void update(int node, int start, int end, int idx, T val) {",
			"        if(start == end) {",
			"            tree[node] = val;",
			"            return;",
			"        }",
			"        int mid = (start + end) / 2;",
			"        if(idx <= mid) {",
			"            update(node * 2, start, mid, idx, val);",
			"        }",
			"        else {",
			"            update(node * 2 + 1, mid + 1, end, idx, val);",
			"        }",
			"        tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);",
			"    }",
			"",
			"    T query(int node, int start, int end, int l, int r) {",
			"        if(r < start || end < l) {",
			"            return identity;",
			"        }",
			"        if(l <= start && end <= r) {",
			"            return tree[node];",
			"        }",
			"        int mid = (start + end) / 2;",
			"        return merge(",
			"            query(node * 2, start, mid, l, r),",
			"            query(node * 2 + 1, mid + 1, end, l, r)",
			"        );",
			"    }",
			"};"
		]
	},
	"Lazy Segment Tree": {
		"prefix": "lazy_segtree",
		"body": [
			"template<typename T, class F>",
			"struct segtree {",
			"    segtree(const vector<T>& arr, F f, T id) : merge(f), identity(id) {",
			"        n = arr.size();",
			"        tree.resize(n * 4, identity);",
			"        lazy.assign(n * 4, 0);",
			"        build(1, 0, n - 1, arr);",
			"    }",
			"",
			"    void update(int l, int r, T val) {",
			"        update(1, 0, n - 1, l, r, val);",
			"    }",
			"",
			"    T query(int l, int r) {",
			"        return query(1, 0, n - 1, l, r);",
			"    }",
			"",
			"  private:",
			"    int n;",
			"    vector<T> tree, lazy;",
			"    F merge;",
			"    T identity;",
			"",
			"    void build(int node, int start, int end, const vector<T>& arr) {",
			"        if(start == end) {",
			"            tree[node] = arr[start];",
			"            return;",
			"        }",
			"        int mid = (start + end) / 2;",
			"        build(node * 2, start, mid, arr);",
			"        build(node * 2 + 1, mid + 1, end, arr);",
			"        tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);",
			"    }",
			"",
			"    void apply(int node, int start, int end, T val) {",
			"        tree[node] += val;",
			"        lazy[node] += val;",
			"    }",
			"",
			"    void push(int node, int start, int end) {",
			"        if(!lazy[node]) {",
			"            return;",
			"        }",
			"        int mid = (start + end) / 2;",
			"        apply(node * 2, start, mid, lazy[node]);",
			"        apply(node * 2 + 1, mid + 1, end, lazy[node]);",
			"        lazy[node] = 0;",
			"    }",
			"",
			"    void update(int node, int start, int end, int l, int r, T val) {",
			"        if(r < start || end < l) {",
			"            return;",
			"        }",
			"        if(l <= start && end <= r) {",
			"            apply(node, start, end, val);",
			"            return;",
			"        }",
			"        push(node, start, end);",
			"        int mid = (start + end) / 2;",
			"        update(node * 2, start, mid, l, r, val);",
			"        update(node * 2 + 1, mid + 1, end, l, r, val);",
			"        tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);",
			"    }",
			"",
			"    T query(int node, int start, int end, int l, int r) {",
			"        if(r < start || end < l) {",
			"            return identity;",
			"        }",
			"        if(l <= start && end <= r) {",
			"            return tree[node];",
			"        }",
			"        push(node, start, end);",
			"        int mid = (start + end) / 2;",
			"        return merge(",
			"            query(node * 2, start, mid, l, r),",
			"            query(node * 2 + 1, mid + 1, end, l, r)",
			"        );",
			"    }",
			"};"
		]
	},
	"Disjoint Set Union": {
		"prefix": "dsu",
		"body": [
			"struct dsu {",
			"  public:",
			"    dsu() : _n(0) {}",
			"    explicit dsu(int n) : _n(n), parent_or_size(n, -1) {}",
			"",
			"    int merge(int a, int b) {",
			"        assert(0 <= a && a < _n);",
			"        assert(0 <= b && b < _n);",
			"        int x = leader(a), y = leader(b);",
			"        if (x == y) return x;",
			"        if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);",
			"        parent_or_size[x] += parent_or_size[y];",
			"        parent_or_size[y] = x;",
			"        return x;",
			"    }",
			"",
			"    bool same(int a, int b) {",
			"        assert(0 <= a && a < _n);",
			"        assert(0 <= b && b < _n);",
			"        return leader(a) == leader(b);",
			"    }",
			"",
			"    int leader(int a) {",
			"        assert(0 <= a && a < _n);",
			"        if (parent_or_size[a] < 0) return a;",
			"        return parent_or_size[a] = leader(parent_or_size[a]);",
			"    }",
			"",
			"    int size(int a) {",
			"        assert(0 <= a && a < _n);",
			"        return -parent_or_size[leader(a)];",
			"    }",
			"",
			"    std::vector<std::vector<int>> groups() {",
			"        std::vector<int> leader_buf(_n), group_size(_n);",
			"        for (int i = 0; i < _n; i++) {",
			"            leader_buf[i] = leader(i);",
			"            group_size[leader_buf[i]]++;",
			"        }",
			"        std::vector<std::vector<int>> result(_n);",
			"        for (int i = 0; i < _n; i++) {",
			"            result[i].reserve(group_size[i]);",
			"        }",
			"        for (int i = 0; i < _n; i++) {",
			"            result[leader_buf[i]].push_back(i);",
			"        }",
			"        result.erase(",
			"            std::remove_if(result.begin(), result.end(),",
			"                           [&](const std::vector<int>& v) { return v.empty(); }),",
			"            result.end());",
			"        return result;",
			"    }",
			"",
			"  private:",
			"    int _n;",
			"    std::vector<int> parent_or_size;",
			"};"
		]
	},
	"Random Number Generator": {
		"prefix": "rng",
		"body": [
			"mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());"
		]
	},
	"Ordered Set": {
		"prefix": "oset",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"using ll = long long;",
			"using ull = unsigned long long;",
			"using pii = pair<int, int>;",
			"using pll = pair<ll, ll>;",
			"using oset = tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>;"
		]
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"vector<bool> sieve(int n) {",
			"    vector<bool> prime(n + 1, 1);",
			"    prime[0] = prime[1] = 0;",
			"    for(int i = 2; i * i <= n; i++) {",
			"        if(prime[i]) {",
			"            for(int j = i * i; j <= n; j += i) {",
			"                prime[j] = 0;",
			"            }",
			"        }",
			"    }",
			"    return prime;",
			"}"
		]
	},
	"Knuth-Morris-Pratt Algorithm": {
		"prefix": "kmp",
		"body": [
			"vector<int> kmp(string s) {",
			"    int n = s.size();",
			"    vector<int> pi(n);",
			"    for(int i = 1, j = 0; i < n; i++) {",
			"        while(j && s[j] != s[i]) {",
			"            j = pi[j - 1];",
			"        }",
			"        j += s[i] == s[j];",
			"        pi[i] = j;",
			"    }",
			"    return pi;",
			"}"
		]
	},
	"Bridge": {
		"prefix": "bridge",
		"body": [
			"vector<vector<int>> adj;",
			"vector<bool> vis;",
			"vector<int> tin, low;",
			"int timer;",
			"",
			"void dfs(int x, int p = -1) {",
			"    vis[x] = 1;",
			"    tin[x] = low[x] = timer++;",
			"    for(auto i : adj[x]) {",
			"        if(i == p) {",
			"            continue;",
			"        }",
			"        if(vis[i]) {",
			"            low[x] = min(low[x], tin[i]);",
			"        }",
			"        else {",
			"            dfs(i, x);",
			"            low[x] = min(low[x], low[i]);",
			"            if(low[i] > tin[x]) {",
			"                // bridge",
			"            }",
			"        }",
			"    }",
			"}"
		]
	},
	"Hashed String": {
		"prefix": "hashed_string",
		"body": [
			"class HashedString {",
			"  private:",
			"    static const ll M = (1LL << 61) - 1;",
			"    static const ll B;",
			"    static vector<ll> pow;",
			"    vector<ll> p_hash;",
			"",
			"    __int128 mul(ll a, ll b) { return (__int128)a * b; }",
			"    ll mod_mul(ll a, ll b) { return mul(a, b) % M; }",
			"",
			"  public:",
			"    HashedString(const string &s) : p_hash(s.size() + 1) {",
			"        while (pow.size() < s.size()) { pow.push_back(mod_mul(pow.back(), B)); }",
			"        p_hash[0] = 0;",
			"        for (int i = 0; i < s.size(); i++) {",
			"            p_hash[i + 1] = (mul(p_hash[i], B) + s[i]) % M;",
			"        }",
			"    }",
			"",
			"    ll get_hash(int start, int end) {",
			"        ll raw_val = p_hash[end + 1] - mod_mul(p_hash[start], pow[end - start + 1]);",
			"        return (raw_val + M) % M;",
			"    }",
			"};",
			"mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());",
			"vector<ll> HashedString::pow = {1};",
			"const ll HashedString::B = uniform_int_distribution<ll>(0, M - 1)(rng);"
		]
	},
	"Smallest Prime Factor": {
		"prefix": "spf",
		"body": [
			"vector<int> sieve(int n) {",
			"    vector<int> spf(n + 1);",
			"    iota(spf.begin(), spf.end(), 0);",
			"    for(int i = 2; i * i <= n; i++) {",
			"        if(spf[i] == i) {",
			"            for(int j = i * i; j <= n; j += i) {",
			"                if(spf[j] == j) {",
			"                    spf[j] = i;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return spf;",
			"}"
		]
	},
	"Choose": {
		"prefix": "choose",
		"body": [
			"const int mx_n = ${1:mx_n};",
			"int mod = ${2:mod};",
			"",
			"ll fac[mx_n + 1], inv[mx_n + 1];",
			"",
			"ll power(ll x, ll y) {",
			"    ll res = 1;",
			"    x %= mod;",
			"    while(y) {",
			"        if(y & 1) {",
			"            res = (res * x) % mod;",
			"        }",
			"        x = (x * x) % mod;",
			"        y = y >> 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"void precompute() {",
			"    fac[0] = 1;",
			"    for(int i = 1; i <= mx_n; i++) {",
			"        fac[i] = (fac[i - 1] * i) % mod;",
			"    }",
			"    inv[mx_n] = power(fac[mx_n], mod - 2);",
			"    for(int i = mx_n; i >= 1; i--) {",
			"        inv[i - 1] = (inv[i] * i) % mod;",
			"    }",
			"}",
			"",
			"ll choose(int n, int k) {",
			"    return (((fac[n] * inv[k]) % mod) * inv[n - k]) % mod;",
			"}"
		]
	},
	"Euler Tour": {
		"prefix": "euler_tour",
		"body": [
			"vector<vector<int>> adj;",
			"vector<int> tin, tout;",
			"int timer = 0;",
			"",
			"void dfs(int x, int p = -1) {",
			"    tin[x] = ++timer;",
			"    for(auto i : adj[x]) {",
			"        if(i == p) {",
			"            continue;",
			"        }",
			"        dfs(i, x);",
			"    }",
			"    tout[x] = timer;",
			"}"
		]
	},
	"Count Inversions": {
		"prefix": "count_inv",
		"body": [
			"ll count_inv(vector<ll>& a, int left, int right) {",
			"    if(left >= right) {",
			"        return 0;",
			"    }",
			"",
			"    ll res = 0;",
			"    int mid = left + (right - left) / 2;",
			"    res += count_inv(a, left, mid);",
			"    res += count_inv(a, mid + 1, right);",
			"",
			"    vector<ll> l(a.begin() + left, a.begin() + mid + 1);",
			"    vector<ll> r(a.begin() + mid + 1, a.begin() + right + 1);",
			"    int i = 0, j = 0, k = left;",
			"    while(i < l.size() && j < r.size()) {",
			"        if(l[i] <= r[j]) {",
			"            a[k++] = l[i++];",
			"        }",
			"        else {",
			"            a[k++] = r[j++];",
			"            res += l.size() - i;",
			"        }",
			"    }",
			"",
			"    while(i < l.size()) {",
			"        a[k++] = l[i++];",
			"    }",
			"    while(j < r.size()) {",
			"        a[k++] = r[j++];",
			"    }",
			"",
			"    return res;",
			"}"
		]
	},
	"Range OR": {
		"prefix": "range_or",
		"body": [
			"int range_or(int x, int y) {",
			"    if(x == y) {",
			"        return x;",
			"    }",
			"    int diff = x ^ y;",
			"    int msb = 31 - __builtin_clz(diff);",
			"    int mask = (1 << (msb + 1)) - 1;",
			"    return y | mask;",
			"}"
		]
	},
	"Z Algorithm": {
		"prefix": "z_algorithm",
		"body": [
			"vector<int> z_function(string s) {",
			"    int n = s.size();",
			"    vector<int> z(n);",
			"    int l = 0, r = 0;",
			"    for(int i = 1; i < n; i++) {",
			"        z[i] = max(0, min(z[i - l], r - i + 1));",
			"        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
			"            l = i;",
			"            r = i + z[i];",
			"            z[i]++;",
			"        }",
			"    }",
			"    return z;",
			"}"
		]
	},
	"Binary Search (First True)": {
		"prefix": "binser_min",
		"body": [
			"int l = $0, r = ;",
			"while(l < r) {",
			"    int mid = l + (r - l) / 2;",
			"    if(OK) {",
			"        r = mid;",
			"    }",
			"    else {",
			"        l = mid + 1;",
			"    }",
			"}"
		]
	},
	"Binary Search (Last True)": {
		"prefix": "binser_max",
		"body": [
			"int l = $0, r = ;",
			"while(l < r) {",
			"    int mid = l + (r - l + 1) / 2;",
			"    if(OK) {",
			"        l = mid;",
			"    }",
			"    else {",
			"        r = mid - 1;",
			"    }",
			"}"
		]
	},
	"Ternary Search": {
		"prefix": "ternary_search",
		"body": [
			"int l = $0, r = ;",
			"while(r - l > 2) {",
			"    int m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;",
			"    if(f(m1) < f(m2)) { // < if max, > if min",
			"        l = m1;",
			"    }",
			"    else {",
			"        r = m2;",
			"    }",
			"}",
			"for(int i = l; i <= r; i++) {",
			"    // find the max/min",
			"}"
		]
	},
	"Tarjan's Algorithm": {
		"prefix": "scc",
		"body": [
			"vector<vector<int>> adj;",
			"vector<int> tin, low, st, comp;",
			"vector<bool> in_stack;",
			"int timer = 0, scc_cnt = 0;",
			"",
			"void dfs(int x) {",
			"    tin[x] = low[x] = ++timer;",
			"    st.pb(x);",
			"    in_stack[x] = 1;",
			"    for(auto i : adj[x]) {",
			"        if(!tin[i]) {",
			"            dfs(i);",
			"        }",
			"        if(in_stack[i]) {",
			"            low[x] = min(low[x], low[i]);",
			"        }",
			"    }",
			"    if(tin[x] == low[x]) {",
			"        while(1) {",
			"            int y = st.back();",
			"            st.pop_back();",
			"            in_stack[y] = 0;",
			"            comp[y] = scc_cnt;",
			"            if(x == y) {",
			"                break;",
			"            }",
			"        }",
			"        scc_cnt++;",
			"    }",
			"}"
		]
	},
	"foo": {
		"prefix": "foo",
		"body": [
			"local ${1:foo} = ${2:bar}",
			"return ${3:baz}"
		]
	}
}
